<!-- <center><img src="http://mooc.e-yantra.org/img/eYantra_logo.svg" alt="e-yantra_logo" style="scale:75%;" /></center> -->

<style>
.back{
	position: fixed;
	width: 250px;
	height: 250px;
	top: 50%;
	left: 50%;
    margin-top: auto; 
    margin-left: auto; 
	opacity: 0.15;
    z-index: -1;
	}
</style>
<!-- <img src="http://mooc.e-yantra.org/img/EyantraLogoMini.png" class="back"> -->

<u><center><h2> Arithmetic Logic Unit </h1></center></u>

<center><h2> 1. Introduction </center></h2>

***


<p align="justify" class="main">An arithmetic logic unit (ALU) is a digital circuit used to perform arithmetic and logic operations. 
It represents the fundamental building block of the central processing unit (CPU) of
a computer. Modern CPUs contain very powerful and complex ALUs. In addition to ALUs,
modern CPUs contain a control unit (CU).</p>

<p align="justify" class="main">Most of the operations of a CPU are performed by one or more ALUs, which load data from
input registers. A register is a small amount of storage available as part of a CPU. The control
unit tells the ALU what operation to perform on that data, and the ALU stores the result in
an output register. The control unit moves the data between these registers, the ALU, and
memory.</p>
<h3> 1.1 Problem Statement.</h3>

<p align="justify" class="main">To Design an 8-bit ALU which performs different set of Arithmetic and logical operations based
on the select input ’s’.It includes writing, compiling and simulating Verilog code in Quartus II
and ModelSim respectively.</p>

<h3> 1.2 Block Diagram 8-bit ALU.</h3>

<p align="center">
  <img src="./images/ALU/NEWALUBLOCK.png", width=300, height=300>
</p>
<center>Figure 1: Block Diagram of 8bit ALU</center>

<h3> 1.3 Implementation Table of 8-bit ALU.</h3>

<p align="justify" class="main">The below table indicates the Arithmetic and Logical operations performed based on the select
input ’s’ and also the output ’y’ obtained for for the given set of input ’a’ and ’b’. The
Arithmetic opertaions that are performed here are:</p>
<ul>
<li>Addition</li>
<li>Subtraction</li>
<li>Multiplication</li>
<li>Division</li>
<li>Increment</li>
<li>Decrement</li>
</ul>
Some of the Logical operations performed here are:<br />
<ul>
<li>Bitwise AND & NAND</li>
<li>Bitwise OR & NOR</li>
<li>Bitwise NOR & XNOR</li>
<li>Shift Right & Shift Left</li>
<li>Rotate Right & Rotate Left</li>
</ul>


| s		| operation      | a		  | b		   | y		              | carry| zero|
| ------| ---------------| -----------| -----------| ---------------------| -----| ----|
| 0000  | Addition       | 11101110   | 11101110   |  00000000 11011100   | 1    | 0   |
| 0001  | Subtraction    | 11101110   | 11101110   |  00000000 00000000   | 0	 | 1   |
| 0010  | Increment      | 11101110   | 11101110   |  00000000 11101111   | 0	 | 0   |
| 0011  | Decrement      | 11101110   | 11101110   |  00000000 11101101   | 0    | 0   |
| 0100  | Multiplication | 11101110   | 11101110   |  11011101 01000100   | 0    | 0   |
| 0101  | Division       | 11101110   | 11101110   |  00000000 00000001   | 0    | 0   |
| 0110  | Bitwise AND    | 11101110   | 11101110   |  00000000 11101110   | 0    | 0   |
| 0111  | Bitwise OR     | 11101110   | 11101110   |  00000000 11101110   | 0    | 0   |
| 1001  | Bitwise XOR    | 11101110   | 11101110   |  00000000 00000000   | 0    | 1   |
| 1010  | Bitwise NOR    | 11101110   | 11101110   |  00000000 00010001   | 0    | 0   |
| 1001  | Bitwise XNOR   | 11101110   | 11101110   |  00000000 00010001   | 0    | 0   |
| 1011  | Shift Left     | 11101110   | 11101110   |  00000000 11111111   | 0    | 0   | 
| 1100  | Shift Right    | 11101110   | 11101110   |  00000000 11011100   | 1    | 0   |
| 1101  | Rotate Right   | 11101110   | 11101110   |  00000000 01110111   | 0    | 0   |
| 1110  | Rotate Right   | 11101110   | 11101110   |  00000000 01110111   | 0    | 0   |
| 1111  | Rotate Left    | 11101110   | 11101110   |  00000000 11011101   | 0    | 0   |

<br />
<center>Table 1: Implementation Table of 8-bit ALU</center>

<center><h2>2. Verilog HDL Codes for 8-bit ALU</center></h2>

***

<h3> 2.1 RTL Description</h3>

<center><iframe id="ytplayer" type="text/html" width="640" height="360"
  src="https://www.youtube.com/embed/XKGkmjUrY8Y?autoplay=1&origin=http://example.com"
  frameborder="0"></iframe></center>

```verilog
// Verilog Design for a 8 -bit ALU .
/* This design will Perform Arithmetic and Logical operations
based on the select input */
// Define module .
module ALU (
input [ 7 : 0 ]a,b,
input [ 3 : 0 ]s, // Define Inputs a,b and select line input s
input en ,clk , // Define clock and enable signal
output [ 15 : 0 ] y, // Define 16 bit ALU output
output carry , zero // Define Flag output
);
reg [ 7 : 0 ] a_in ; // Local registers for input 'a '.
reg [ 7 : 0 ] b_in ; // Local registers for input 'b '.
reg [ 1 : 0 ] flags ;
/* Local register to store carry bit in flags [0] &
zero flag bit in flags [1] */
reg [ 15 : 0 ] out_y ; // Local register to store 16 bit output 'y '.

always @( posedge clk , negedge en)
begin
if(en ==1) // if en =1 , reset all outputs
begin
a_in <= 0;
b_in <= 0;
y <= 0;
carry <= 0;
zero <= 0;
end
else
begin
a_in <= a; // if en =1 , latch all output flit flops
b_in <= b;
y <= out_y ;
carry <= flags [ 0 ] ;
zero <= flags [ 1 ] ;
end
end

always @ (a_in ,b_in ,s)
begin
flags = 2' b00; // set flags to zero
case (s)
4'd0:
begin
out_y ={8 'd0 ,( a_in + b_in )}; // addition
flags [ 0 ] = out_y [ 8 ] ; // carry is set if generated .
end
4'd1:
begin
out_y ={8 'd0 ,( a_in - b_in )}; // Subtraction
flags [ 0 ] = out_y [ 8 ] ; // carry is set if Borrow is taken .
end
4'd2:
begin
out_y ={8 'd0 ,( a_in + 1'b1 )}; // Increment
flags [ 0 ] = out_y [ 8 ] ; // carry is set if generated .
end
4'd3: begin
out_y ={8 'd0 ,( a_in - 1'b1 )}; // Decrement
flags [ 0 ] = out_y [ 8 ] ; // carry is set if Borrow is taken .
end
4'd4: out_y =( a_in * b_in ); // Multiplication .
4'd5: out_y =( a_in / b_in ); // Division
4'd6: out_y ={8 'd0 ,( a_in & b_in )}; // Bitwise AND
4'd7: out_y ={8 'd0 ,( a_in | b_in )}; // Bitwise OR
4'd8: out_y ={8 'd0 ,( a_in ^ b_in )}; // Bitwise XOR
4'd9: out_y ={8 'd0 ,~( a_in & b_in )}; // Bitwise NAND
4' d10: out_y ={8 'd0 ,~( a_in | b_in )}; // Bitwise NOR
4' d11: out_y ={8 'd0 ,~( a_in ^ b_in )}; // Bitwise XNOR
4' d12:
begin
flags [ 0 ] = a_in [ 7 ] ; // Update carry flag
out_y ={8 'd0 ,( a_in < <1)}; // Shift Left
end
4' d13: begin
flags [ 0 ] = a_in [ 0 ] ; // Update carry flag
out_y ={8 'd0 ,( a_in > >1)}; // Shift Right
end
4' d14: out_y ={8 'd0 , a_in [ 0 ] ,a_in [ 7 : 1 ] }; // right rotate
4' d15: out_y ={8 'd0 , a_in [ 6 : 0 ] ,a_in [ 7 ] }; // left rotate
default : out_y =16 ' d0;
endcase
if( out_y == 0)
flags [ 1 ] = 1; // set zero flag if output is zero
end // End of case structure .
endmodule
```

<h3> 2.2 Testbench for 8-bit ALU.</h3>

```verilog
// Verilog code for TestBench of 8 -bit ALU
// Define module
module tb_ALU ;
reg [ 7 : 0 ]a; reg [ 7 : 0 ]b; reg [ 3 : 0 ]s; // Define I/O ports
reg clk; reg en;
wire [ 15 : 0 ]y;
wire carry ;
wire zero ;

// Map all the I/O ports with DUT .
ALU uut (.a(a) ,.b(b) ,.s(s) ,. en(en ) ,. clk(clk ) ,.y(y) ,. carry ( carry ) ,. zero ( zero ));

// Initialise Input pins with 0
initial begin
a = 0;
b = 0;
s = 0;
en =1;
clk = 0;

end
always
begin clk = ~clk ;#5; end // Generate a clock of period 10 units
initial begin
#50;

a = 8' b11101110 ; // Initialise 8bit input value for a & b.
b = 8' b11101110 ;#29;

// Initialise 's' value to perform different operations .

s = 4' b0001 ;#30;
s = 4' b0010 ;#30;
en =0
s = 4' b0001 ;#30;
s = 4' b0010 ;#30;
s = 4' b0011 ;#30;
s = 4' b0100 ;#30;
s = 4' b0101 ;#30;
s = 4' b0110 ;#30;
s = 4' b0111 ;#30;
s = 4' b1000 ;#30;
s = 4' b1001 ;#30;
s = 4' b1010 ;#30;
s = 4' b1011 ;#30;
s = 4' b1100 ;#30;
s = 4' b1101 ;#30;
s = 4' b1110 ;#30;
s = 4' b1111 ;#30;

end // End of initial block
endmodule // End of module .
```

<center><h2> 3. Implementing on quartus II</center></h2>

***

Follow the below steps :
<ol>
<li><p align="justify" class="main">Start a <b>New Project</b> in Quartus Lite software</p></li>

<p align="center">
  <img src="./images/ALU/PRO IMG1.png">
</p>
<center>Figure 2: Creating New Project</center><br />

<li><p align="justify" class="main">You will see this screen after completing all the steps. For detailed steps refer the <b>Getting Started with Quartus</b> section from Task 0.</p></li>



<p align="center">
  <img src="./images/ALU/projimg2.png">
</p>
<center>Figure 3: Summary</center><br />

<li><p align="justify" class="main">We will be using <b>Verilog</b> throughout this project. Create a <b>New Verilog HDL file</b>.</p></li>


<p align="center">
  <img src="./images/ALU/PROJIMG3.png">
</p>
<center>Figure 4: New Verilog File</center><br />

<li>Type the code for 8-bit ALU in this file.</li>

<p align="center">
  <img src="./images/ALU/proentry.png">
</p>
<center>Figure 5: Verilog Code:ALU</center><br />


<li>Go to <b>File→Save as</b> and save the file.</li>

> *__Note:__ File name should be same as module name.*

<p align="center">
  <img src="./images/ALU/save4.png">
</p>
<center>Figure 6: Saving the file</center><br />

<li><p align="justify" class="main">Go to <b>Project→Set as Top-Level Entity.</b> The <b>ALU</b> file is our main file and make
sure you have selected this file while setting the top level entity.</p></li>


<p align="center">
  <img src="./images/ALU/alusetnew2.png">
</p>
<center>Figure 7: Setting Top level entity</center><br />

<li> Goto <b>Processing→Start Compilation.</b></li>

<p align="center">
  <img src="./images/ALU/startcompialu.png">
</p>
<center>Figure 8: Compiling the Design</center><br />

<li><p align="justify" class="main">You can verify whether all the files are compiled successfully by checking the highlighted
tabs i.e. <b>Messages</b> and <b>Tasks</b> tab.</p></li>


<p align="center">
  <img src="./images/ALU/compilation done.png">
</p>
<center>Figure 9: Verification(Flow Summary)</center>
</ol>

<center><h2> 4. RTL Circuit of the implemented design </center></h2>

***

<b>Steps to get RTL circuit.</b>
<ol>
<li>Goto <b>Tools→Netlist Viewers→RTL Viewer.</b></li>


<p align="center">
  <img src="./images/ALU/compilation done.png">
</p>
<center>Figure 10: RTL Viewer</center><br />

<li> The below figure shows the equivalent RTL circuit of 8-bit ALU.</li>


<p align="center">
  <img src="./images/ALU/rtlalu new.png">
</p>
<center>Figure 11: RTL Design for 8-bit ALU</center>
</ol>

<center><h2>5. Implementing on Modelsim</center></h2>

***


<p align="justify" class="main">For more detailed procedure on using ModelSim, refer <b>Getting Started with Quartus</b> section from Task 0. You can find Verilog HDL TestBench code
below.</p>
<ol>
<li>Create a New Verilog file in Quartus Prime.Type in the TestBench code&nbsp; provided in this
document and save the file with the same name as the module name</li>

<p align="center">
  <img src="./images/ALU/test1.png">
</p>
<center>Figure 12: Save TestBench file</center><br />

<li>Go to <b>Assignments→Settings</b>.</li>

<p align="center">
  <img src="./images/ALU/test2.png">
</p>
<center>Figure 13: Settings</center><br />

<li><p align="justify" class="main">Navigate to <b>Simulation</b> under <b>EDA Tool Settings</b>. Set the language as Verilog HDL. Select
<b>Compile TestBench</b> and then click on <b>Test Benches</b>.</p></li>

<p align="center">
  <img src="./images/ALU/test3.png">
</p>
<center>Figure 14: Adding the TestBench file</center><br />

<li>Click on <b>New</b>, this opens another dialogue box.</li>

<p align="center">
  <img src="./images/ALU/test4.png">
</p>
<center>Figure 15: Adding the TestBench file</center><br />

<li><p align="justify" class="main">Now type in the TestBench name(In this design , its <b>tb_ripple_carry_adder</b>). Now click
on the highlighted Browse button.Find the TestBench file(it can be found in the project
directory) and click on <b>Open.</b> Now click on <b>Add</b>,then <b>OK</b>.</p></li><br />
</ol>

<p align="center">
  <img src="./images/ALU/test5.png">
</p>
<center>Figure 16: Adding the TestBench file</center><br />

<b>Functional Simulation using NativeLink Feature</b>
<ol>
<li> Go to <b>Processing→Start Compilation</b></li>

<p align="center">
  <img src="./images/ALU/posttest1.png">
</p>
<center>Figure 17: Compiling the project</center><br />

<li><p align="justify" class="main"> Go to <b>Tools→Run Simulation Tool→RTL Simulation</b> to automatically run the EDA
simulator (ModelSim-Altera) and to compile all necessary design files.</p></li>

> *__Note:__ If you cannot see the graph, Click on the waveform window and select the <b>Zoom all</b> option.*


<p align="center">
  <img src="./images/ALU/posttest2.png">
</p>
<center>Figure 18: RTL Simulation</center><br />

<li><p align="justify" class="main">Finally ModelSim-Altera tool opens up with simulated waveform. Click on <b>Run all</b> icon
on the tool box to display the waveform.</p></li>


<p align="center">
  <img src="./images/ALU/waveform1.png">
</p>
<center>Figure 19: RTL Simulation</center>
</ol>

<center><h2> 6. Simulation Results </center></h2>

***

<b>Simulation waveform of the Verilog Design</b><br>

<p align="justify" class="main">The Result shown below can be verified by comparing it with the Truth Table
provided in section 1.4 above. You can observe individual bits of a particular signal by clicking on the ’+’ icon.</p>

> *__Observation:__ Based on the select input <b>’s’</b> the opertion is performed on input <b>’a’</b> and <b>’b’</b> and
the 16 bit result is generated on output line <b>’y’</b>.The <b>carry</b> flag is raised when carry is generated
and <b>Zero</b> flag is raised if the result is zero during the operation.*


<p align="center">
  <img src="./images/ALU/waveform1n.png">
</p>
<center>Figure 20: Simulation waveform</center><br />


















