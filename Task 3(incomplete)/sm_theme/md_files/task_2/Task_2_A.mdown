<style>
.back{
	position: fixed;
	width: 300px;
	height: 300px;
	top: 50%;
	left: 50%;
    margin-top: auto; 
    margin-left: auto; 
	opacity: 0.05;
	}
.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 50%;
}
h1 {
  text-align: center;
}
p.date {
  text-align: right;
}
p.main {
  text-align: justify;
}

</style>



<center><h1>Task 2 A : Analog to Digital Converter (ADC)</h1></center>

<hr>
<center><h2>1. Introduction</h2></center>
<hr>

<p align="justify" class="main">
In this theme, we will be using the De0 Nano development board which contains an  ADC128S022  low  power,  eight-channel  CMOS 12-bit analog-to-digital converter.  This ADC provides conversion throughput rates 
of 50 ksps to 200 ksps.  It can be configured to accept up to eight input signals at inputs IN0 through IN7.  These eight input signals are connected to the 2x13 header, as 
shown in figure below.  The remaining I/Os of the 2x13 header are a DC +3.3V (VCC33), a GND and 13 pins, which are connected directly to the Cyclone IV E device.


> *__Important :__ Read [Using DE0-Nano ADC](./Task_2_A/Using_DE0-Nano_ADC.pdf) as this document contains necessary information for successfully completing this task. This is __mandatory__.* 

<p align="center">
  <img src="./Task_2_A/ADC_Wiring.png">
</p>

<p align="justify" class="main">
In this task, we will be designing a <b>3-channel ADC Control module</b> which will send channel addresses to on-board ADC128S022 and fetch digital data of analog value present on that corresponding channel. The on-board ADC128S022 will convert it to its equivalent 12-bit digital value which 
can be read by the FPGA (using ADC Control module).</p>

<p align="justify" class="main">
We  will  be  communicating  with  the  ADC128S022  using  SPI  Protocol. It operates in a 16 cycle frame. The user is required to provide the SCLK, CS and DIN to 
the ADC128S022 and capture the DOUT signal as it is serially transmitted.</p>

<p align="center">
  <img src="./Task_2_A/Timing_diagram.png">
</p>

<p align="justify" class="main">
The  DOUT  signal  provides  the  12-bit  converted  value  of  the  selected channel.  On power-up,  channel  0  is  selected by default, while <b>subsequent reads  
will  use  the  address provided in the previous operational frame</b>.  The data bits are transmitted in descending order, such that the highest-order bit is delivered first.  It is 
captured by the user on the rising edge of SCLK.</p>

<p align="justify" class="main">
The DIN  signal is used to select the channel to be converted in the following frame. It is delivered in descending order, and is captured by the ADC128S022 on the positive 
edges of SCLK. In order to avoid potential race conditions, the user should <b>generate DIN on the negative edges of SCLK</b>.</p>

<p align="justify" class="main">
CS should be lowered on the first falling edge of SCLK and raised on the last rising edge  of  an  operational  frame.  The  SCLK  frequency  is  limited  to  a  
range  of  0.8  to 3.2 MHz in which the ADC will function correctly.</p>



<hr>
<center><h2>2. Interpretation of ADC output and Analog Input</h2></center>
<hr>


<p align="justify" class="main">
ADC128S022 outputs  a  12-bit  value  based  on  the  analog voltage  at  its  channel. ADC  output  of <b>000000000000</b> corresponds to <b>0 V</b> and an output of <b>111111111111</b> corresponds to <b>3.3 V</b> (the  reference  voltage  of  the  ADC128S022  is  3.3 V,  hence  it's  maximum  digital output is for 3.3V).</p><br>
Hence,<br>  

Maximum Input voltage = 3.3 V<br>

Highest Output value from ADC128S022 in decimal = 4095 (i.e. 111111111111 in binary)<br>

Voltage represented per LSB in Output (Resolution) = 3.3 V/4095 = <b>0.805 mV</b><br>

<p align="justify" class="main">
Now,  we  know  the  relation  between  the  ADC128S022 output  and  Voltage.  By simply multiplying the above value i.e. Resolution with the ADC128S022 output (in decimal), we can calculate the voltage at 
the chosen input channel of the ADC.</p><br>

<b>Example :</b>  

<p align="justify" class="main"><i>Suppose the output of ADC is '100011111100' (2300 in decimal) then, </i></p> 
<p align="justify" class="main"><i>Analog Input = 0.805 mV*2300 = 1.85 V</i></p>

<p align="justify" class="main"><i>Now suppose, analog input is 2.5 V then,</i></p>
<p align="justify" class="main"><i>ADC output = 2.5/0.805 mV = 3105 in decimal = '110000100001' in binary.</i></p> 

<p align="justify" class="main">
<i>Now, you know how to convert the analog input voltage to corresponding 12-bit digital output and vice-versa.</i></p><br>


<hr>
<center><h2>3. Problem Statement</h2></center>
<hr>

<p align="justify" class="main">
In this task, you will be designing a control module which controls the on-board ADC.
Basically, this "control module" sends necessary commands to the on-board ADC which is ADC128S022 and fetches the digital output. Your designed control module should have following inputs and outputs :
</p>  

Inputs|Outputs
---------|---------
clk_50|adc_cs_n
dout|din
-|adc_sck
-|d_out_ch5, d_out_ch6, d_out_ch7 (12-bit) 
-|data_frame (optional)

1. **clk_50** : This is 50MHz clock input to the adc control module. All other signals must be synchronized w.r.t this clock.  
2. **dout** : This is converted binary data which is received serially by adc control module. This is the digital output from ADC128S022 (outputted serially), so your designed module reads this serial data and outputs 12-bit data (parallel data) on d_out_chX output bus.
3. **adc_cs_n** : Chip Select pin. When low selects the on-board ADC128S022.
4. **din** : This output is used to give **ADC_ADDR** input to on-board ADC128S022. Refer [Datasheet](http://www.ti.com/lit/ds/symlink/adc128s022.pdf) for more information. **Use channels 5, 6 & 7**.
5. **adc_sck** : This output is given as input to ADC128S022 and it serves as a device clock for the ADC128S022. **This clock signal should be 2.5MHz**.
6. **d_out_chX** (X = 5,6,7) : 12-bit binary output for channel X i.e. for ADC channel 5 the converted binary output will be available at d_out_ch5. 
7. **data_frame** : This is a 2-bit bus which is used only to represent 16-cycle operational frame. This is optional, but it is recommended to use this signal for better visualization of signals.


> **_Important :_**
> * _For this task **adc_sck = 2.5MHz**, **ADC channels = 5, 6 & 7** should be followed strictly._
> * _You are not allowed to use any code or part of the code which is available online._
> * _You are not allowed to use Nios architecture /IP blocks._
> * _You must only refer [Using DE0-Nano ADC](./Task_2_A/Using_DE0-Nano_ADC.pdf)._
> * _Additionally you can also refer to [ADC128S022 datasheet](http://www.ti.com/lit/ds/symlink/adc128s022.pdf)._

<hr>
Project File : <u><a href="./project_files/adc_control.zip" download>Download TASK 2 A</a></u>
<hr>

<b>Steps :</b> 

<ol>
<li><p align="justify" class="main">Open <b>adc_control.qpf</b>. You will find <b>adc_control.v</b> file where module is defined. <b>Do not make any changes to input and output ports</b>. Firstly, without writing any logic, perform <b>Analysis & Synthesis (Ctrl+K)</b>. Now, Run <b>RTL Simulation</b>. You will see some waveforms in ModelSim window, these are the expected outputs.</p><a name = "SD"></a></li>
<li><p align="justify" class="main">Now, implement adc control module which outputs correct <b>din & adc_sck</b> signals, reads <b>dout</b> correctly and outputs the correct 12-bit data on correct output bus <b>d_out_chX</b>.
You can create other verilog files in the project but <b>adc_control.v should be the Top Level Entity</b>.</p><a name = "SD"></a></li>

Refer below image to write logic for 3-channel ADC control module.

<p align="center">
  <img src="./Task_2_A/wave_table.png">
</p>

> _**Note :** In above image clock is actually **adc_sck** and data_ch5 = d_out_ch5 (similarly for other two outputs). Open the image in New Tab to view it better._


> _**Important Reminder :** For this task **adc_sck = 2.5MHz**, **ADC channels = 5, 6 & 7** should be followed strictly._

<li><p align="justify" class="main">After completing, run <b>RTL Simulation</b>. Actual output should match desired output. For Eg : <b>adc_sck</b> is <b>actual output</b> and <b>adc_sck_exp</b> is the <b>desired or expected output</b>.
 You can also check ModelSim Transcript window for "No errors" or "Errors" message.</p><a name = "SD"></a></li>
 
</ol>
<br />

<p align=center><b>…BestWishes!…</b></p>