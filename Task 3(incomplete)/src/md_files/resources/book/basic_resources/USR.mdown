<!-- <center><img src="http://mooc.e-yantra.org/img/eYantra_logo.svg" alt="e-yantra_logo" style="scale:75%;" /></center> -->

<style>
.back{
	position: fixed;
	width: 250px;
	height: 250px;
	top: 50%;
	left: 50%;
    margin-top: auto; 
    margin-left: auto; 
	opacity: 0.15;
    z-index: -1;
	}
</style>
<!-- <img src="http://mooc.e-yantra.org/img/EyantraLogoMini.png" class="back"> -->


<center><h2><u> Universal Shift Register </u></h2></center>
              

<center><h2> 1. Introduction</h2></center>

***

<h3> 1.1    What is a Register?</h3>


<p align="justify" class="main">Flip flops can be used to store a single bit of binary data (1 or 0). However, in order to store multiple bits of data, 
we need multiple flip flops. N flip flops are to be connected in an order to store n bits of data. A <b>Register</b> is a device which is used to 
store such information. It is a group of flip flops connected in series used to store multiple bits of data.</p>

<h3>1.2    Shift Registers</h3>


<p align="justify" class="main">The information stored within these registers can be transferred with the help of
<b>Shift Registers</b>. Shift Register is a group of flip flops used to store multiple bits
of data. The bits stored in such registers can be made to move within the registers
and in/out of the registers by applying clock pulses. An n-bit shift register can be
formed by connecting n flip-flops where each flip flop stores a single bit of data.</p><br />
Shift registers are basically of 4 types. These are:
<ol>
<li> Serial In Serial Out shift register</li>
<li>Serial In parallel Out shift register</li>
<li>Parallel In Serial Out shift register</li>
<li>Parallel In parallel Out shift register</li>
</ol>

<h3>1.3    Serial-In Serial-Out Shift Register</h3>


<p align="justify" class="main">The shift register, which allows serial input (one bit after the other through a single
data line) and produces a serial output is known as Serial-In Serial-Out shift register.
Since there is only one output, the data leaves the shift register one bit at a time in
a serial pattern, thus the name Serial-In Serial-Out Shift Register.
The logic circuit given below shows a serial-in serial-out shift register. The circuit
consists of four D flip-flops which are connected in a serial manner. All these flip-
flops are synchronous with each other since the same clock signal is applied to each
flip flop.</p>

<p align="center">
  <img src="./images/USR/circuit diagram/SISO.png">
</p> 
<center>Figure 1:  SISO Shift Register</center>

<h3>1.4    Serial-In Parallel-Out Shift Register</h3>


<p align="justify" class="main">The shift register, which allows serial input (one bit after the other through a single
data line) and produces a parallel output is known as Serial-In Parallel-Out shift
register.</p>

<p align="justify" class="main">The logic circuit given below shows a serial-in-parallel-out shift register. The circuit
consists of four D flip-flops which are connected. The clear (CLR) signal is connected
in addition to the clock signal to all the 4 flip flops in order to RESET them. The
output of the first flip flop is connected to the input of the next flip flop and so on.
All these flip-flops are synchronous with each other since the same clock signal is
applied to each flip flop.</p>

<p align="center">
  <img src="./images/USR/circuit diagram/SIPO.png">
</p> 
<center>Figure 2:  SIPO Shift Register</center></center></center>


<h3> 1.5    Parellel-In Serial-Out Shift Register</h3>


<p align="justify" class="main">The PISO(Parellel-in Serial-out) shift register has one of the most important appli-
cation among the shift register, and it is to convert parellel data into serial data,
which is extensively used in communication.<br />
The circuit consists of four D flip-flops which are connected. The clock input is
directly connected to all the flip flops but the input data is connected individually
to each flip flop through a multiplexer at the input of every flip flop. The output of
the previous flip flop and parallel data input are connected to the input of the MUX
and the output of MUX is connected to the next flip flop. All these flip-flops are
synchronous with each other since the same clock signal is applied to each flip flop.</p>

<p align="center">
  <img src="./images/USR/circuit diagram/PISO.png">
</p> 
<center>Figure 3:  PISO Shift Register</center></center>

<h3>1.6    Parallel-In Parallel-Out Shift Register</h3>


<p align="justify" class="main">The shift register, which allows parallel input (data is given separately to each flip
flop and in a simultaneous manner) and also produces a parallel output is known as
Parallel-In parallel-Out shift register.</p>

<p align="justify" class="main">The logic circuit given below shows a parallel-in-parallel-out shift register. The
circuit consists of four D flip-flops which are connected. The clear (CLR) signal and
clock signals are connected to all the 4 flip flops. In this type of register, there are no
interconnections between the individual flip-flops since no serial shifting of the data
is required. Data is given as input separately for each flip flop and in the same way,
output also collected individually from each flip flop.</p>

<p align="center">
  <img src="./images/USR/circuit diagram/PIPO.png">
</p> 
<center>Figure 4:  PIPO Shift Register</center>

<h3> 1.7    Universal Shift Register</h3>


<p align="justify" class="main">A Universal shift register is a register is a combination of all the above 4 shift registers with. Universal shift registers are used as memory elements in computers. A
Unidirectional shift register is capable of shifting in only one direction. A bidirectional shift register is capable of shifting in both the directions. The Universal shift
register is a combination design of bidirectional shift register and a unidirectional shift register with parallel load provision.</p>

<p align="center">
  <img src="./images/USR/circuit diagram/uni_operation.png">
</p> 
<center>Figure 5:  Choosing the operation through MUX select lines</center><br />


<p align="center">
  <img src="./images/USR/circuit diagram/universal.png">
</p> 
<center>Figure 6:  Universal Shift Register</center>


<center><h2> 2. Verilog HDL Code for Universal Shift Register</h2></center>

***


<p align="justify" class="main">The Universal Shift Register has been implemented as it contains all different 
types of shift registers in itself.</p>

<h3> 2.1    RTL Description</h3>

<center><iframe id="ytplayer" type="text/html" width="640" height="360"
  src="https://www.youtube.com/embed/f2JAwlXH-c8?autoplay=1&origin=http://example.com"
  frameborder="0"></iframe></center>

```verilog
module Universal_Shift_Register_Verilog(
input [3:0]i, //Define pins for parellel input
input [1:0]sel, //Define select line pins to choose the operation
input clk,rst,il,ir, //Define clock,reset, serial input for
//shift left and serial input for shift right

output reg [3:0]out_bit); //Define output pins

always @ (posedge clk, negedge rst ) //Execute the logic whenever positive edge of
//clock or negative edge of Reset is encountered

begin
if(rst==0) //if rst = 0, then clear the output
out_bit=4'b000;
else
begin
case(sel) //check select lines to determine type of
//operation
2'b00:begin end //Retain the data
2'b01:begin
out_bit={ir,out_bit[3:1]}; //shift right operation
end
2'b10:begin
out_bit={out_bit[2:0],il}; //Shift left operation
end
2'b11:begin
out_bit = i; //parellel input-output operation
end
default:begin end
endcase
end
end
endmodule
```


<h3>2.2 Testbench</h3>

```verilog
module Universal_Shift_Register_tb;
reg [3:0]i; reg[1:0]sel; reg clk; reg rst; reg il;reg ir; //Define all input ports
wire [3:0]out_bit; //Define all output ports
Universal_Shift_Register_Verilog uut(.i(i), //Map testbench ports with DUT ports

.sel(sel),

.clk(clk),
.rst(rst),
.out_bit(out_bit),
.il(il),
.ir(ir));

initial begin
rst = 1'b0; //Initialze values on all input pins
clk = 0;
ir = 0;
il = 0;
sel = 2'b00;
i = 4'b0000;
end
always
begin
clk = ~clk; #5; //Define Clock operation
end
initial begin
#50;
rst = 1; #50 //Different Combinations of input
ir = 1;
sel = 2'b01;#10;
ir = 0;#10;
ir = 1;#10;
ir = 0;#10;
il = 1;
sel = 2'b00;#50
sel = 2'b10;
il = 1;#10
il = 0;#10
il = 0;#10
sel = 2'b11;#5
i = 4'b1111;
#100;
end
endmodule
```

<center><h2> 3. Implementation in Quartus Prime</h2></center>

***


<p align="justify" class="main">To Implement the design in Quartus Software, follow these steps(For more 
detailed information on the following steps, Refer <b>Getting Started with Quartus</b> section from Task 0.</p>

> *__Note:__  The language used is Verilog HDL.*
<ol>

<li>Create a New Project using the Project Wizard.</li>

<p align="center">
  <img src="./images/USR/USR1.png">
</p> 
<center>Figure 7:  Project Summary</center></center><br />

<li>Create a New Verilog File.</li>


<p align="center">
  <img src="./images/USR/Implementation_quartus/2.png">
</p> 
<center>Figure 8:  Creating a Verilog File</center><br />

<li><p align="justify" class="main">Type in the Verilog code provided in this Document and save the file(make sure file name is same as module name).</p></li>


<p align="center">
  <img src="./images/USR/USR2.png">
</p> 
<center>Figure 9:  Code typed and saved</center><br />

> __Note:__ If  module  name  is  different  from  project  name,  then  manually set the verilog file as Top-Level Module by:Right Click on <b><File_name> -> Set as Top-Level Entity</b>


<p align="center">
  <img src="./images/USR/USR3.png">
</p> 
<center>Figure 10:  Setting top-level entity</center><br />

<li><p align="justify" class="main">Compile the Design either by double clicking <b>COMPILE DESIGN</b> or clicking on the <b>Play</b> button.</p></li>


<p align="center">
  <img src="./images/USR/USR4.png">
</p> 
<center>Figure 11:  Code compilation</center><br />

> *__Note:__ The Compilation is complete when you see these <b>Green Tick</b> marks.If even one of them have <b>Red Cross</b> it means the compilation has failed*


<p align="center">
  <img src="./images/USR/Implementation_quartus/4_1.png">
</p> 
<center>Figure 12:  Successful compilation</center><br />

<li><p align="justify" class="main">Upon successful compilation, to view the RTL Circuit, Go to <b>TOOLS→NETLIST VIEWERS→RTL VIEWER.</b></p></li>


<p align="center">
  <img src="./images/USR/usr5.png">
</p> 
<center>Figure 13:  Opening the RTL Viewer</center>

</ol>


<center><h2>4. RTL Circuit of the Implemented Design </h2></center>

***

The below RTL circuit is the result of our design:


<p align="center">
  <img src="./images/USR/usr6.png">
</p> 
<center>Figure 14:  RTL Circuit of Universal Shift Register</center>


<center><h2> 5. Implementing in ModelSim</h2></center>

***

<p align="justify" class="main">The TestBench shown here is a Verilog TestBench. For more detailed procedure on
using ModelSim, Refer <b>Getting Started with Quartus</b> section from Task 0.</p>

<ol>
<li>Create a new verilog file in Quartus Prime.</li>


<p align="center">
  <img src="./images/USR/usr9.png">
</p> 
<center>Figure 15:  Creating new verilog file</center><br />


<li><p align="justify" class="main">Type in the Testbench code provided in this document and save the file with the same name as the module name.</p></li>


<p align="center">
  <img src="./images/USR/usr10.png">
</p> 
<center>Figure 16:  typing the testbench code</center><br />

<li>Go to <b>ASSIGNMENTS→SETTINGS</b></li>


<p align="center">
  <img src="./images/USR/usr11.png">
</p> 
<center>Figure 17:  opening settings</center><br />

<li>Navigate to <b>SIMULATION</b> under <b>EDA TOOL SETTINGS</b></center></li>

<p align="center">
  <img src="./images/USR/implementing_modelsim/4.png">
</p> 
<center>Figure 18:  Navigate to simulation settings</center><br />

<li><p align="justify" class="main">Set the language (<b>FORMAT FOR OUTPUT NETLIST</b>) as Verilog HDL. Select <b>COMPILE TEST BENCH</b> and then click on <b>TEST BENCHES...</b></p></li>


<p align="center">
  <img src="./images/USR/implementing_modelsim/5.png">
</p> 
<center>Figure 19:  Configuring the Settings</center><br />

<li><p align="justify" class="main">Click on <b>NEW</b>, this opens another dialogue box. Now type in the testbench name(In this design , its <b>Universal_Shift_Register_tb</b>).  Now click on thehighlighted browse button</p></li>


<p align="center">
  <img src="./images/USR/implementing_modelsim/6_1.png">
</p> 
<center>Figure 20:  Adding the Tesbench file</center><br />


<li><p align="justify" class="main">Find the testbench file(it can be found in the project directory) and click on <b>OPEN.</b></p></li>


<p align="center">
  <img src="./images/USR/usr13.png">
</p> 
<center>Figure 21:  Finding the file in the project directory</center><br />

<li><p align="justify" class="main">Now click on <b>ADD</b>,then <b>OKAY</b>, then <b>OKAY</b> again and finally click on <b>APPLY</b></p></li>
  
> *__Note:__ The  <b>APPLY</b>  button  will  be  highlighted  after <b>OKAY</b>  has  been
clicked on all previous windows*


<p align="center">
  <img src="./images/USR/usr14.png">
</p> 
<center>Figure 22:  Finalising the testbench adding process</center><br />


<li><p align="justify" class="main">To start the simulation, go to <b>TOOLS -> RUN SIMULATION TOOL -> RTL SIMULATION</b>. This will open ModelSim and display the simulation waveform.</p></li>


<p align="center">
  <img src="./images/USR/usr15.png">
</p> 
<center>Figure 23:  Running the Simulation</center>
</ol>

<center><h2> 6. Simulation Results</h2></center>

***


<p align="justify" class="main">The waveform shown below is the result of the simulation.
Initially when rst=0, the output is reset to <b>0000</b>. After <b>50 ns, rst</b> is set and the
register is in normal operation. When <b>sel = 00</b>, the register retains the previous
data. At <b>0.1 ns, sel=01</b>, so the shift register is set to <b>’Shift right operation’</b>.
At every consecutive clock cycle until <b>0.14 ns</b>, it can be seen that the shift register
ouput is shifted right while the MSB is loaded with the value of <b>’ir’</b>. <b>At 0.14ns,sel=00</b>, so until <b>0.19ns</b>, the shift register retains the value. <b>At 0.19 ns, sel=10</b>,
The shift register is set to <b>Shift left Operation</b> and at each consecutive clock
cycle, the Shift register shifts the data left and loads the LSB with data on the
’il’ pin. Finally, at <b>0.22 ns, sel=11</b>, this sets the shift register to <b>Parellel input mode</b>, so for every consecutive clock cycle, the shift register is updated with the
data on the 4 bit parellel input ’i’.</p>

<p align="center">
  <img src="./images/USR/usrsimu.png">
</p> 
<center>Figure 24:  Simulation Waveform</center>

